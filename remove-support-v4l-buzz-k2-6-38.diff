diff -Nru cinelerra.orig//cinelerra/channelpicker.C cinelerra/cinelerra/channelpicker.C
--- cinelerra.orig//cinelerra/channelpicker.C	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/channelpicker.C	2011-02-17 13:31:30.147880002 -0500
@@ -39,7 +39,7 @@
 #include "recordgui.h"
 #include "recordmonitor.h"
 #include "theme.h"
-#include "vdevicebuz.h"
+//#include "vdevicebuz.h"
 #include "vdeviceprefs.h"
 #include "videodevice.h"
 
@@ -280,7 +280,7 @@
 //	printf("PrefsChannelPicker::PrefsChannelPicker 1\n");
 	this->mwindow = mwindow;
 	this->prefs = prefs;
-	VDeviceBUZ::get_inputs(&input_sources);
+//	VDeviceBUZ::get_inputs(&input_sources);
 }
 
 PrefsChannelPicker::~PrefsChannelPicker()
diff -Nru cinelerra.orig//cinelerra/Makefile.am cinelerra/cinelerra/Makefile.am
--- cinelerra.orig//cinelerra/Makefile.am	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/Makefile.am	2011-02-17 13:31:30.147880002 -0500
@@ -305,10 +305,8 @@
 		    vattachmentpoint.C \
 		    vautomation.C \
 		    vdevicebase.C \
-		    vdevicebuz.C \
 		    vdevicedvb.C \
 		    vdeviceprefs.C \
-		    vdevicev4l.C \
 		    vdevicev4l2.C \
 		    vdevicev4l2jpeg.C \
 		    vdevicex11.C \
diff -Nru cinelerra.orig//cinelerra/reversemake cinelerra/cinelerra/reversemake
--- cinelerra.orig//cinelerra/reversemake	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/reversemake	2011-02-17 13:31:30.151880002 -0500
@@ -32,10 +32,8 @@
 make $OBJDIR/vedits.o
 make $OBJDIR/vedit.o
 make $OBJDIR/vdevicex11.o
-make $OBJDIR/vdevicev4l.o
 make $OBJDIR/vdeviceprefs.o
 make $OBJDIR/vdevicelml.o
-make $OBJDIR/vdevicebuz.o
 make $OBJDIR/vdevicebase.o
 make $OBJDIR/vdevice1394.o
 make $OBJDIR/vautomation.o
diff -Nru cinelerra.orig//cinelerra/vdevicebuz.C cinelerra/cinelerra/vdevicebuz.C
--- cinelerra.orig//cinelerra/vdevicebuz.C	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/vdevicebuz.C	1969-12-31 19:00:00.000000000 -0500
@@ -1,796 +0,0 @@
-
-/*
- * CINELERRA
- * Copyright (C) 2008 Adam Williams <broadcast at earthling dot net>
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- * 
- */
-
-// ALPHA C++ can't compile 64 bit headers
-#undef _LARGEFILE_SOURCE
-#undef _LARGEFILE64_SOURCE
-#undef _FILE_OFFSET_BITS
-
-#include "assets.h"
-#include "bcsignals.h"
-#include "channel.h"
-#include "chantables.h"
-#include "condition.h"
-#include "file.inc"
-#include "mutex.h"
-#include "picture.h"
-#include "playbackconfig.h"
-#include "preferences.h"
-#include "recordconfig.h"
-#include "strategies.inc"
-#include "vdevicebuz.h"
-#include "vframe.h"
-#include "videoconfig.h"
-#include "videodevice.h"
-
-#include <errno.h>
-#include <stdint.h>
-#include <linux/kernel.h>
-//#include <linux/videodev2.h>
-#include <linux/videodev.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <unistd.h>
-
-
-
-#define READ_TIMEOUT 5000000
-
-
-VDeviceBUZInput::VDeviceBUZInput(VDeviceBUZ *device)
- : Thread(1, 1, 0)
-{
-	this->device = device;
-	buffer = 0;
-	buffer_size = 0;
-	total_buffers = 0;
-	current_inbuffer = 0;
-	current_outbuffer = 0;
-	done = 0;
-	output_lock = new Condition(0, "VDeviceBUZInput::output_lock");
-	buffer_lock = new Mutex("VDeviceBUZInput::buffer_lock");
-}
-
-VDeviceBUZInput::~VDeviceBUZInput()
-{
-	if(Thread::running())
-	{
-		done = 1;
-		Thread::cancel();
-		Thread::join();
-	}
-
-	if(buffer)
-	{
-		for(int i = 0; i < total_buffers; i++)
-		{
-			delete [] buffer[i];
-		}
-		delete [] buffer;
-		delete [] buffer_size;
-	}
-	delete output_lock;
-	delete buffer_lock;
-}
-
-void VDeviceBUZInput::start()
-{
-// Create buffers
-	total_buffers = device->device->in_config->capture_length;
-	buffer = new char*[total_buffers];
-	buffer_size = new int[total_buffers];
-	bzero(buffer_size, sizeof(int) * total_buffers);
-	for(int i = 0; i < total_buffers; i++)
-	{
-		buffer[i] = new char[INPUT_BUFFER_SIZE];
-	}
-
-	Thread::start();
-}
-
-void VDeviceBUZInput::run()
-{
-    struct buz_sync bsync;
-
-// Wait for frame
-	while(1)
-	{
-		Thread::enable_cancel();
-		if(ioctl(device->jvideo_fd, BUZIOC_SYNC, &bsync) < 0)
-		{
-			perror("VDeviceBUZInput::run BUZIOC_SYNC");
-			if(done) return;
-			Thread::disable_cancel();
-		}
-		else
-		{
-			Thread::disable_cancel();
-
-
-
-			int new_buffer = 0;
-			buffer_lock->lock("VDeviceBUZInput::run");
-// Save only if the current buffer is free.
-			if(!buffer_size[current_inbuffer])
-			{
-				new_buffer = 1;
-// Copy to input buffer
-				memcpy(buffer[current_inbuffer], 
-					device->input_buffer + bsync.frame * device->breq.size,
-					bsync.length);
-
-// Advance input buffer number and decrease semaphore.
-				buffer_size[current_inbuffer] = bsync.length;
-				increment_counter(&current_inbuffer);
-			}
-
-			buffer_lock->unlock();
-
-			if(ioctl(device->jvideo_fd, BUZIOC_QBUF_CAPT, &bsync.frame))
-				perror("VDeviceBUZInput::run BUZIOC_QBUF_CAPT");
-
-			if(new_buffer) output_lock->unlock();
-		}
-	}
-}
-
-void VDeviceBUZInput::get_buffer(char **ptr, int *size)
-{
-// Increase semaphore to wait for buffer.
-	int result = output_lock->timed_lock(READ_TIMEOUT, "VDeviceBUZInput::get_buffer");
-
-
-// The driver has its own timeout routine but it doesn't work because
-// because the tuner lock is unlocked and relocked with no delay.
-//	int result = 0;
-//	output_lock->lock("VDeviceBUZInput::get_buffer");
-
-	if(!result)
-	{
-// Take over buffer table
-		buffer_lock->lock("VDeviceBUZInput::get_buffer");
-		*ptr = buffer[current_outbuffer];
-		*size = buffer_size[current_outbuffer];
-		buffer_lock->unlock();
-	}
-	else
-	{
-//printf("VDeviceBUZInput::get_buffer 1\n");
-		output_lock->unlock();
-	}
-}
-
-void VDeviceBUZInput::put_buffer()
-{
-	buffer_lock->lock("VDeviceBUZInput::put_buffer");
-	buffer_size[current_outbuffer] = 0;
-	buffer_lock->unlock();
-	increment_counter(&current_outbuffer);
-}
-
-void VDeviceBUZInput::increment_counter(int *counter)
-{
-	(*counter)++;
-	if(*counter >= total_buffers) *counter = 0;
-}
-
-void VDeviceBUZInput::decrement_counter(int *counter)
-{
-	(*counter)--;
-	if(*counter < 0) *counter = total_buffers - 1;
-}
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-VDeviceBUZ::VDeviceBUZ(VideoDevice *device)
- : VDeviceBase(device)
-{
-	reset_parameters();
-	render_strategies.append(VRENDER_MJPG);
-	tuner_lock = new Mutex("VDeviceBUZ::tuner_lock");
-}
-
-VDeviceBUZ::~VDeviceBUZ()
-{
-	close_all();
-	delete tuner_lock;
-}
-
-int VDeviceBUZ::reset_parameters()
-{
-	jvideo_fd = 0;
-	input_buffer = 0;
-	output_buffer = 0;
-	frame_buffer = 0;
-	frame_size = 0;
-	frame_allocated = 0;
-	input_error = 0;
-	last_frame_no = 0;
-	temp_frame = 0;
-	user_frame = 0;
-	mjpeg = 0;
-	total_loops = 0;
-	output_number = 0;
-	input_thread = 0;
-	brightness = 32768;
-	hue = 32768;
-	color = 32768;
-	contrast = 32768;
-	whiteness = 32768;
-}
-
-int VDeviceBUZ::close_input_core()
-{
-	if(input_thread)
-	{
-		delete input_thread;
-		input_thread = 0;
-	}
-
-
-	if(device->r)
-	{
-		if(jvideo_fd) close(jvideo_fd);
-		jvideo_fd = 0;
-	}
-
-	if(input_buffer)
-	{
-		if(input_buffer > 0)
-			munmap(input_buffer, breq.count * breq.size);
-		input_buffer = 0;
-	}
-}
-
-int VDeviceBUZ::close_output_core()
-{
-//printf("VDeviceBUZ::close_output_core 1\n");
-	if(device->w)
-	{
-		int n = -1;
-// 		if(ioctl(jvideo_fd, BUZIOC_QBUF_PLAY, &n) < 0)
-// 			perror("VDeviceBUZ::close_output_core BUZIOC_QBUF_PLAY");
-		if(jvideo_fd) close(jvideo_fd);
-		jvideo_fd = 0;
-	}
-	if(output_buffer)
-	{
-		if(output_buffer > 0)
-			munmap(output_buffer, breq.count * breq.size);
-		output_buffer = 0;
-	}
-	if(temp_frame)
-	{
-		delete temp_frame;
-		temp_frame = 0;
-	}
-	if(mjpeg)
-	{
-		mjpeg_delete(mjpeg);
-		mjpeg = 0;
-	}
-	if(user_frame)
-	{
-		delete user_frame;
-		user_frame = 0;
-	}
-//printf("VDeviceBUZ::close_output_core 2\n");
-	return 0;
-}
-
-
-int VDeviceBUZ::close_all()
-{
-//printf("VDeviceBUZ::close_all 1\n");
-	close_input_core();
-//printf("VDeviceBUZ::close_all 1\n");
-	close_output_core();
-//printf("VDeviceBUZ::close_all 1\n");
-	if(frame_buffer) delete frame_buffer;
-//printf("VDeviceBUZ::close_all 1\n");
-	reset_parameters();
-//printf("VDeviceBUZ::close_all 2\n");
-	return 0;
-}
-
-#define COMPOSITE_TEXT "Composite"
-#define SVIDEO_TEXT "S-Video"
-#define BUZ_COMPOSITE 0
-#define BUZ_SVIDEO 1
-
-void VDeviceBUZ::get_inputs(ArrayList<Channel*> *input_sources)
-{
-	Channel *new_source = new Channel;
-
-	new_source = new Channel;
-	strcpy(new_source->device_name, COMPOSITE_TEXT);
-	input_sources->append(new_source);
-
-	new_source = new Channel;
-	strcpy(new_source->device_name, SVIDEO_TEXT);
-	input_sources->append(new_source);
-}
-
-int VDeviceBUZ::open_input()
-{
-	device->channel->use_norm = 1;
-	device->channel->use_input = 1;
-
-	device->picture->use_brightness = 1;
-	device->picture->use_contrast = 1;
-	device->picture->use_color = 1;
-	device->picture->use_hue = 1;
-	device->picture->use_whiteness = 1;
-
-// Can't open input until after the channel is set
-	return 0;
-}
-
-int VDeviceBUZ::open_output()
-{
-// Can't open output until after the channel is set
-	return 0;
-}
-
-int VDeviceBUZ::set_channel(Channel *channel)
-{
-	if(!channel) return 0;
-
-	tuner_lock->lock("VDeviceBUZ::set_channel");
-
-	if(device->r)
-	{
-		close_input_core();
-		open_input_core(channel);
-	}
-	else
-	{
-		close_output_core();
-		open_output_core(channel);
-	}
-
-	tuner_lock->unlock();
-
-
-	return 0;
-}
-
-void VDeviceBUZ::create_channeldb(ArrayList<Channel*> *channeldb)
-{
-	;
-}
-
-int VDeviceBUZ::set_picture(PictureConfig *picture)
-{
-	this->brightness = (int)((float)picture->brightness / 100 * 32767 + 32768);
-	this->hue = (int)((float)picture->hue / 100 * 32767 + 32768);
-	this->color = (int)((float)picture->color / 100 * 32767 + 32768);
-	this->contrast = (int)((float)picture->contrast / 100 * 32767 + 32768);
-	this->whiteness = (int)((float)picture->whiteness / 100 * 32767 + 32768);
-
-
- 	tuner_lock->lock("VDeviceBUZ::set_picture");
-	if(device->r)
-	{
-		close_input_core();
-		open_input_core(0);
-	}
-	else
-	{
-		close_output_core();
-		open_output_core(0);
-	}
- 	tuner_lock->unlock();
-// 
-// 
-// TRACE("VDeviceBUZ::set_picture 1");
-// 	tuner_lock->lock("VDeviceBUZ::set_picture");
-// TRACE("VDeviceBUZ::set_picture 2");
-// 
-// 
-// 
-// 	struct video_picture picture_params;
-// // This call takes a long time in 2.4.22
-// 	if(ioctl(jvideo_fd, VIDIOCGPICT, &picture_params) < 0)
-// 		perror("VDeviceBUZ::set_picture VIDIOCGPICT");
-// 	picture_params.brightness = brightness;
-// 	picture_params.hue = hue;
-// 	picture_params.colour = color;
-// 	picture_params.contrast = contrast;
-// 	picture_params.whiteness = whiteness;
-// // This call takes a long time in 2.4.22
-// 	if(ioctl(jvideo_fd, VIDIOCSPICT, &picture_params) < 0)
-// 		perror("VDeviceBUZ::set_picture VIDIOCSPICT");
-// 	if(ioctl(jvideo_fd, VIDIOCGPICT, &picture_params) < 0)
-// 		perror("VDeviceBUZ::set_picture VIDIOCGPICT");
-// 
-// 
-// TRACE("VDeviceBUZ::set_picture 10");
-// 
-// 
-// 	tuner_lock->unlock();
-
-	return 0;
-}
-
-int VDeviceBUZ::get_norm(int norm)
-{
-	switch(norm)
-	{
-		case NTSC:          return VIDEO_MODE_NTSC;      break;
-		case PAL:           return VIDEO_MODE_PAL;       break;
-		case SECAM:         return VIDEO_MODE_SECAM;     break;
-	}
-}
-
-int VDeviceBUZ::read_buffer(VFrame *frame)
-{
-	tuner_lock->lock("VDeviceBUZ::read_buffer");
-	if(!jvideo_fd) open_input_core(0);
-
-// Get buffer from thread
-	char *buffer = 0;
-	int buffer_size = 0;
-	if(input_thread) 
-		input_thread->get_buffer(&buffer, &buffer_size);
-
-	if(buffer)
-	{
-		frame->allocate_compressed_data(buffer_size);
-		frame->set_compressed_size(buffer_size);
-
-// Transfer fields to frame
-		if(device->odd_field_first)
-		{
-			long field2_offset = mjpeg_get_field2((unsigned char*)buffer, buffer_size);
-			long field1_len = field2_offset;
-			long field2_len = buffer_size - field2_offset;
-
-			memcpy(frame->get_data(), buffer + field2_offset, field2_len);
-			memcpy(frame->get_data() + field2_len, buffer, field1_len);
-		}
-		else
-		{
-			bcopy(buffer, frame->get_data(), buffer_size);
-		}
-
-		input_thread->put_buffer();
-		tuner_lock->unlock();
-	}
-	else
-	{
-		tuner_lock->unlock();
-		Timer timer;
-// Allow other threads to lock the tuner_lock under NPTL.
-		timer.delay(100);
-	}
-
-
-	return 0;
-}
-
-int VDeviceBUZ::open_input_core(Channel *channel)
-{
-	jvideo_fd = open(device->in_config->buz_in_device, O_RDONLY);
-
-	if(jvideo_fd <= 0)
-	{
-		fprintf(stderr, "VDeviceBUZ::open_input %s: %s\n", 
-			device->in_config->buz_in_device,
-			strerror(errno));
-		jvideo_fd = 0;
-		return 1;
-	}
-
-// Create input sources
-	get_inputs(&device->input_sources);
-
-// Set current input source
-	if(channel)
-	{
-		for(int i = 0; i < 2; i++)
-		{
-			struct video_channel vch;
-			vch.channel = channel->input;
-			vch.norm = get_norm(channel->norm);
-
-//printf("VDeviceBUZ::open_input_core 2 %d %d\n", vch.channel, vch.norm);
-			if(ioctl(jvideo_fd, VIDIOCSCHAN, &vch) < 0)
-				perror("VDeviceBUZ::open_input_core VIDIOCSCHAN ");
-		}
-	}
-
-
-// Throw away
-//     struct video_capability vc;
-// 	if(ioctl(jvideo_fd, VIDIOCGCAP, &vc) < 0)
-// 		perror("VDeviceBUZ::open_input VIDIOCGCAP");
-
-// API dependant initialization
-	if(ioctl(jvideo_fd, BUZIOC_G_PARAMS, &bparm) < 0)
-		perror("VDeviceBUZ::open_input BUZIOC_G_PARAMS");
-
-	bparm.HorDcm = 1;
-	bparm.VerDcm = 1;
-	bparm.TmpDcm = 1;
-	bparm.field_per_buff = 2;
-	bparm.img_width = device->in_config->w;
-	bparm.img_height = device->in_config->h / bparm.field_per_buff;
-	bparm.img_x = 0;
-	bparm.img_y = 0;
-//	bparm.APPn = 0;
-//	bparm.APP_len = 14;
-	bparm.APP_len = 0;
-	bparm.odd_even = 0;
-    bparm.decimation = 0;
-    bparm.quality = device->quality;
-    bzero(bparm.APP_data, sizeof(bparm.APP_data));
-
-	if(ioctl(jvideo_fd, BUZIOC_S_PARAMS, &bparm) < 0)
-		perror("VDeviceBUZ::open_input BUZIOC_S_PARAMS");
-
-// printf("open_input %d %d %d %d %d %d %d %d %d %d %d %d\n", 
-// 		bparm.HorDcm,
-// 		bparm.VerDcm,
-// 		bparm.TmpDcm,
-// 		bparm.field_per_buff,
-// 		bparm.img_width,
-// 		bparm.img_height,
-// 		bparm.img_x,
-// 		bparm.img_y,
-// 		bparm.APP_len,
-// 		bparm.odd_even,
-//     	bparm.decimation,
-//     	bparm.quality);
-
-	breq.count = device->in_config->capture_length;
-	breq.size = INPUT_BUFFER_SIZE;
-	if(ioctl(jvideo_fd, BUZIOC_REQBUFS, &breq) < 0)
-		perror("VDeviceBUZ::open_input BUZIOC_REQBUFS");
-
-//printf("open_input %s %d %d %d %d\n", device->in_config->buz_in_device, breq.count, breq.size, bparm.img_width, bparm.img_height);
-	if((input_buffer = (char*)mmap(0, 
-		breq.count * breq.size, 
-		PROT_READ, 
-		MAP_SHARED, 
-		jvideo_fd, 
-		0)) == MAP_FAILED)
-		perror("VDeviceBUZ::open_input mmap");
-
-
-// Set picture quality
-	struct video_picture picture_params;
-// This call takes a long time in 2.4.22
-	if(ioctl(jvideo_fd, VIDIOCGPICT, &picture_params) < 0)
-		perror("VDeviceBUZ::set_picture VIDIOCGPICT");
-	picture_params.brightness = brightness;
-	picture_params.hue = hue;
-	picture_params.colour = color;
-	picture_params.contrast = contrast;
-	picture_params.whiteness = whiteness;
-// This call takes a long time in 2.4.22
-	if(ioctl(jvideo_fd, VIDIOCSPICT, &picture_params) < 0)
-		perror("VDeviceBUZ::set_picture VIDIOCSPICT");
-	if(ioctl(jvideo_fd, VIDIOCGPICT, &picture_params) < 0)
-		perror("VDeviceBUZ::set_picture VIDIOCGPICT");
-
-
-
-
-// Start capturing
-	for(int i = 0; i < breq.count; i++)
-	{
-        if(ioctl(jvideo_fd, BUZIOC_QBUF_CAPT, &i) < 0)
-			perror("VDeviceBUZ::open_input BUZIOC_QBUF_CAPT");
-	}
-
-
-	input_thread = new VDeviceBUZInput(this);
-	input_thread->start();
-//printf("VDeviceBUZ::open_input_core 2\n");
-	return 0;
-}
-
-int VDeviceBUZ::open_output_core(Channel *channel)
-{
-//printf("VDeviceBUZ::open_output 1\n");
-	total_loops = 0;
-	output_number = 0;
-	jvideo_fd = open(device->out_config->buz_out_device, O_RDWR);
-	if(jvideo_fd <= 0)
-	{
-		perror("VDeviceBUZ::open_output");
-		return 1;
-	}
-
-
-// Set current input source
-	if(channel)
-	{
-		struct video_channel vch;
-		vch.channel = channel->input;
-		vch.norm = get_norm(channel->norm);
-
-		if(ioctl(jvideo_fd, VIDIOCSCHAN, &vch) < 0)
-			perror("VDeviceBUZ::open_output_core VIDIOCSCHAN ");
-	}
-
-	breq.count = 10;
-	breq.size = INPUT_BUFFER_SIZE;
-	if(ioctl(jvideo_fd, BUZIOC_REQBUFS, &breq) < 0)
-		perror("VDeviceBUZ::open_output BUZIOC_REQBUFS");
-	if((output_buffer = (char*)mmap(0, 
-		breq.count * breq.size, 
-		PROT_READ | PROT_WRITE, 
-		MAP_SHARED, 
-		jvideo_fd, 
-		0)) == MAP_FAILED)
-		perror("VDeviceBUZ::open_output mmap");
-
-	if(ioctl(jvideo_fd, BUZIOC_G_PARAMS, &bparm) < 0)
-		perror("VDeviceBUZ::open_output BUZIOC_G_PARAMS");
-
-	bparm.decimation = 1;
-	bparm.HorDcm = 1;
-	bparm.field_per_buff = 2;
-	bparm.TmpDcm = 1;
-	bparm.VerDcm = 1;
-	bparm.img_width = device->out_w;
-	bparm.img_height = device->out_h / bparm.field_per_buff;
-	bparm.img_x = 0;
-	bparm.img_y = 0;
-	bparm.odd_even = 0;
-
-	if(ioctl(jvideo_fd, BUZIOC_S_PARAMS, &bparm) < 0)
-		perror("VDeviceBUZ::open_output BUZIOC_S_PARAMS");
-//printf("VDeviceBUZ::open_output 2\n");
-	return 0;
-}
-
-
-
-int VDeviceBUZ::write_buffer(VFrame *frame, EDL *edl)
-{
-//printf("VDeviceBUZ::write_buffer 1\n");
-	tuner_lock->lock("VDeviceBUZ::write_buffer");
-
-	if(!jvideo_fd) open_output_core(0);
-
-	VFrame *ptr = 0;
-	if(frame->get_color_model() != BC_COMPRESSED)
-	{
-		if(!temp_frame) temp_frame = new VFrame;
-		if(!mjpeg)
-		{
-			mjpeg = mjpeg_new(device->out_w, device->out_h, 2);
-			mjpeg_set_quality(mjpeg, device->quality);
-			mjpeg_set_float(mjpeg, 0);
-		}
-		ptr = temp_frame;
-		mjpeg_compress(mjpeg, 
-			frame->get_rows(), 
-			frame->get_y(), 
-			frame->get_u(), 
-			frame->get_v(),
-			frame->get_color_model(),
-			device->cpus);
-		temp_frame->allocate_compressed_data(mjpeg_output_size(mjpeg));
-		temp_frame->set_compressed_size(mjpeg_output_size(mjpeg));
-		bcopy(mjpeg_output_buffer(mjpeg), temp_frame->get_data(), mjpeg_output_size(mjpeg));
-	}
-	else
-		ptr = frame;
-
-// Wait for frame to become available
-// Caused close_output_core to lock up.
-// 	if(total_loops >= 1)
-// 	{
-// 		if(ioctl(jvideo_fd, BUZIOC_SYNC, &output_number) < 0)
-// 			perror("VDeviceBUZ::write_buffer BUZIOC_SYNC");
-// 	}
-
-	if(device->out_config->buz_swap_fields)
-	{
-		long field2_offset = mjpeg_get_field2((unsigned char*)ptr->get_data(), 
-			ptr->get_compressed_size());
-		long field2_len = ptr->get_compressed_size() - field2_offset;
-		memcpy(output_buffer + output_number * breq.size, 
-			ptr->get_data() + field2_offset, 
-			field2_len);
-		memcpy(output_buffer + output_number * breq.size +field2_len,
-			ptr->get_data(), 
-			field2_offset);
-	}
-	else
-	{
-		bcopy(ptr->get_data(), 
-			output_buffer + output_number * breq.size, 
-			ptr->get_compressed_size());
-	}
-
-	if(ioctl(jvideo_fd, BUZIOC_QBUF_PLAY, &output_number) < 0)
-		perror("VDeviceBUZ::write_buffer BUZIOC_QBUF_PLAY");
-
-	output_number++;
-	if(output_number >= breq.count)
-	{
-		output_number = 0;
-		total_loops++;
-	}
-	tuner_lock->unlock();
-//printf("VDeviceBUZ::write_buffer 2\n");
-
-	return 0;
-}
-
-void VDeviceBUZ::new_output_buffer(VFrame *output,
-	int colormodel)
-{
-//printf("VDeviceBUZ::new_output_buffer 1 %d\n", colormodel);
-	if(user_frame)
-	{
-		if(colormodel != user_frame->get_color_model())
-		{
-			delete user_frame;
-			user_frame = 0;
-		}
-	}
-
-	if(!user_frame)
-	{
-		switch(colormodel)
-		{
-			case BC_COMPRESSED:
-				user_frame = new VFrame;
-				break;
-			default:
-				user_frame = new VFrame(0,
-					device->out_w,
-					device->out_h,
-					colormodel,
-					-1);
-				break;
-		}
-	}
-	user_frame->set_shm_offset(0);
-	output = user_frame;
-//printf("VDeviceBUZ::new_output_buffer 2\n");
-}
-
-
-ArrayList<int>* VDeviceBUZ::get_render_strategies()
-{
-	return &render_strategies;
-}
-
diff -Nru cinelerra.orig//cinelerra/vdevicebuz.h cinelerra/cinelerra/vdevicebuz.h
--- cinelerra.orig//cinelerra/vdevicebuz.h	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/vdevicebuz.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,130 +0,0 @@
-
-/*
- * CINELERRA
- * Copyright (C) 2008 Adam Williams <broadcast at earthling dot net>
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- * 
- */
-
-#ifndef VDEVICEBUZ_H
-#define VDEVICEBUZ_H
-
-#include "buz.h"
-#include "channel.inc"
-#include "condition.inc"
-#include "guicast.h"
-#include "libmjpeg.h"
-#include "mutex.inc"
-#include "thread.h"
-#include "vdevicebase.h"
-#include "vdevicebuz.inc"
-#include "vframe.inc"
-
-
-#define INPUT_BUFFER_SIZE 0x40000
-
-// Let's get real.  The Buz driver doesn't work.  If the buffers overflow
-// for enough time it locks up and can't be recovered except by a
-// SIGINT and restart.  We need to cascade the buffer reading in another
-// ring buffer thread, have it read continuously, and cancel it if it 
-// dies.  How about if we do this in SCHED_RR and wait for it to die before 
-// implementing cancellation?
-
-
-class VDeviceBUZInput : public Thread
-{
-public:
-	VDeviceBUZInput(VDeviceBUZ *device);
-	~VDeviceBUZInput();
-	void start();
-	void run();
-	void get_buffer(char **ptr, int *size);
-	void put_buffer();
-	void increment_counter(int *counter);
-	void decrement_counter(int *counter);
-	VDeviceBUZ *device;
-
-	char **buffer;
-	int *buffer_size;
-	int total_buffers;
-	int current_inbuffer;
-	int current_outbuffer;
-	Condition *output_lock;
-	Mutex *buffer_lock;
-	int done;
-};
-
-
-class VDeviceBUZ : public VDeviceBase
-{
-public:
-	VDeviceBUZ(VideoDevice *device);
-	~VDeviceBUZ();
-
-	friend class VDeviceBUZInput;
-
-	int open_input();
-	int open_output();
-	int close_all();
-	int read_buffer(VFrame *frame);
-	int write_buffer(VFrame *frames, EDL *edl);
-	int reset_parameters();
-	ArrayList<int>* get_render_strategies();
-	int set_channel(Channel *channel);
-	int get_norm(int norm);
-	static void get_inputs(ArrayList<Channel*> *input_sources);
-	int set_picture(PictureConfig *picture);
-	int get_best_colormodel(int colormodel);
-	void create_channeldb(ArrayList<Channel*> *channeldb);
-	void new_output_buffer(VFrame *output, int colormodel);
-
-
-private:
-	int open_input_core(Channel *channel);
-	int close_input_core();
-	int open_output_core(Channel *channel);
-	int close_output_core();
-
-	int jvideo_fd;
-	char *input_buffer, *frame_buffer, *output_buffer;
-	long frame_size, frame_allocated;
-	int input_error;
-//	quicktime_mjpeg_hdr jpeg_header;
-	long last_frame_no;
-	ArrayList<int> render_strategies;
-// Temporary frame for compressing output data
-	VFrame *temp_frame;
-// Frame given to user to acquire data
-	VFrame *user_frame;
-	mjpeg_t *mjpeg;
-	Mutex *tuner_lock;
-	VDeviceBUZInput *input_thread;
-
-	struct buz_params bparm;
-	struct buz_requestbuffers breq;
-// Can't CSYNC the first loop
-	int total_loops;
-// Number of output frame to load
-	int output_number;
-
-	int brightness;
-	int hue;
-	int color;
-	int contrast;
-	int whiteness;
-};
-
-#endif
diff -Nru cinelerra.orig//cinelerra/vdevicebuz.inc cinelerra/cinelerra/vdevicebuz.inc
--- cinelerra.orig//cinelerra/vdevicebuz.inc	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/vdevicebuz.inc	1969-12-31 19:00:00.000000000 -0500
@@ -1,28 +0,0 @@
-
-/*
- * CINELERRA
- * Copyright (C) 2008 Adam Williams <broadcast at earthling dot net>
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- * 
- */
-
-#ifndef VDEVICEBUZ_INC
-#define VDEVICEBUZ_INC
-
-class VDeviceBUZ;
-class VDeviceBUZInput;
-
-#endif
diff -Nru cinelerra.orig//cinelerra/vdevicev4l.C cinelerra/cinelerra/vdevicev4l.C
--- cinelerra.orig//cinelerra/vdevicev4l.C	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/vdevicev4l.C	1969-12-31 19:00:00.000000000 -0500
@@ -1,574 +0,0 @@
-
-/*
- * CINELERRA
- * Copyright (C) 2008 Adam Williams <broadcast at earthling dot net>
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- * 
- */
-
-// V4L2 is incompatible with large file support
-// ALPHA C++ can't compile 64 bit headers
-#undef _FILE_OFFSET_BITS
-#undef _LARGEFILE_SOURCE
-#undef _LARGEFILE64_SOURCE
-
-
-#include "assets.h"
-#include "bcsignals.h"
-#include "channel.h"
-#include "chantables.h"
-#include "clip.h"
-#include "file.h"
-#include "picture.h"
-#include "preferences.h"
-#include "quicktime.h"
-#include "recordconfig.h"
-#include "vdevicev4l.h"
-#include "vframe.h"
-#include "videodevice.h"
-
-#include <unistd.h>
-#include <sys/ioctl.h>
-#include <fcntl.h>
-#include <sys/mman.h>
-#include <string.h>
-
-VDeviceV4L::VDeviceV4L(VideoDevice *device)
- : VDeviceBase(device)
-{
-	initialize();
-}
-
-VDeviceV4L::~VDeviceV4L()
-{
-}
-
-int VDeviceV4L::initialize()
-{
-	capture_buffer = 0;
-	capture_frame_number = 0;
-	read_frame_number = 0;
-	shared_memory = 0;
-	initialization_complete = 0;
-	return 0;
-}
-
-int VDeviceV4L::open_input()
-{
-	device->channel->use_frequency = 1;
-	device->channel->use_fine = 1;
-	device->channel->use_norm = 1;
-	device->channel->use_input = 1;
-
-
-	device->picture->use_brightness = 1;
-	device->picture->use_contrast = 1;
-	device->picture->use_color = 1;
-	device->picture->use_hue = 1;
-	device->picture->use_whiteness = 1;
-
-	if((input_fd = open(device->in_config->v4l_in_device, O_RDWR)) < 0)
-	{
-		perror("VDeviceV4L::open_input");
-		return 1;
-	}
-	else
-	{
-		v4l1_get_inputs();
-		close(input_fd);
-	}
-	return 0;
-}
-
-int VDeviceV4L::close_all()
-{
-	close_v4l();
-	return 0;
-}
-
-int VDeviceV4L::close_v4l()
-{
-	unmap_v4l_shmem();
-	if(input_fd != -1) close(input_fd);
-	return 0;
-}
-
-int VDeviceV4L::unmap_v4l_shmem()
-{
-	if(capture_buffer)
-	{
-		if(shared_memory)
-			munmap(capture_buffer, capture_params.size);
-		else
-			delete capture_buffer;
-		capture_buffer = 0;
-	}
-	return 0;
-}
-
-int VDeviceV4L::v4l_init()
-{
-	int i;
-
-	input_fd = open(device->in_config->v4l_in_device, O_RDWR);
-
-	if(input_fd < 0)
-		perror("VDeviceV4L::v4l_init");
-	else
-	{
-		set_cloexec_flag(input_fd, 1);
-		set_mute(0);
-		if(ioctl(input_fd, VIDIOCGWIN, &window_params) < 0)
-			perror("VDeviceV4L::v4l_init VIDIOCGWIN");
-		window_params.x = 0;
-		window_params.y = 0;
-		window_params.width = device->in_config->w;
-		window_params.height = device->in_config->h;
-		window_params.chromakey = 0;
-		window_params.flags = 0;
-		window_params.clipcount = 0;
-		if(ioctl(input_fd, VIDIOCSWIN, &window_params) < 0)
-			perror("VDeviceV4L::v4l_init VIDIOCSWIN");
-		if(ioctl(input_fd, VIDIOCGWIN, &window_params) < 0)
-			perror("VDeviceV4L::v4l_init VIDIOCGWIN");
-
-		device->in_config->w = window_params.width;
-		device->in_config->h = window_params.height;
-
-		PictureConfig picture(0);
-		set_picture(&picture);
-
-		if(ioctl(input_fd, VIDIOCGMBUF, &capture_params) < 0)
-			perror("VDeviceV4L::v4l_init VIDIOCGMBUF");
-
-		capture_buffer = (char*)mmap(0, 
-			capture_params.size, 
-			PROT_READ|PROT_WRITE, 
-			MAP_SHARED, 
-			input_fd, 
-			0);
-
-		capture_frame_number = 0;
-
-		if(capture_buffer == MAP_FAILED)
-		{
-// Use read instead.
-			perror("VDeviceV4L::v4l_init mmap");
-			shared_memory = 0;
-			capture_buffer = new char[capture_params.size];
-		}
-		else
-		{
-// Get all frames capturing
-			shared_memory = 1;
-		}
-	}
-	got_first_frame = 0;
-	return 0;
-}
-
-void VDeviceV4L::v4l1_start_capture()
-{
-	for(int i = 0; i < MIN(capture_params.frames, device->in_config->capture_length); i++)
-		capture_frame(i);
-}
-
-
-
-
-
-
-
-
-int VDeviceV4L::v4l1_get_inputs()
-{
-	struct video_channel channel_struct;
-	int i = 0, done = 0;
-	char *new_source;
-
-	while(!done && i < 20)
-	{
-		channel_struct.channel = i;
-		if(ioctl(input_fd, VIDIOCGCHAN, &channel_struct) < 0)
-		{
-// Finished
-			done = 1;
-		}
-		else
-		{
-			Channel *channel = new Channel;
-			strcpy(channel->device_name, channel_struct.name);
-			device->input_sources.append(channel);
-		}
-		i++;
-	}
-	return 0;
-}
-
-int VDeviceV4L::set_mute(int muted)
-{
-// Open audio, which obviously is controlled by the video driver.
-// and apparently resets the input source.
-	v4l1_set_mute(muted);
-}
-
-int VDeviceV4L::v4l1_set_mute(int muted)
-{
-	struct video_audio audio;
-
-    if(ioctl(input_fd, VIDIOCGAUDIO, &audio))
-	if(ioctl(input_fd, VIDIOCGAUDIO, &audio) < 0)
-	    perror("VDeviceV4L::ioctl VIDIOCGAUDIO");
-
-	audio.volume = 65535;
-	audio.bass = 65535;
-	audio.treble = 65535;
-	if(muted)
-		audio.flags |= VIDEO_AUDIO_MUTE | VIDEO_AUDIO_VOLUME;
-	else
-		audio.flags &= ~VIDEO_AUDIO_MUTE;
-
-    if(ioctl(input_fd, VIDIOCSAUDIO, &audio) < 0)
-		perror("VDeviceV4L::ioctl VIDIOCSAUDIO");
-	return 0;
-}
-
-
-int VDeviceV4L::set_cloexec_flag(int desc, int value)
-{
-	int oldflags = fcntl(desc, F_GETFD, 0);
-	if(oldflags < 0) return oldflags;
-	if(value != 0) 
-		oldflags |= FD_CLOEXEC;
-	else
-		oldflags &= ~FD_CLOEXEC;
-	return fcntl(desc, F_SETFD, oldflags);
-}
-
-
-
-
-
-int VDeviceV4L::get_best_colormodel(Asset *asset)
-{
-	int result = BC_RGB888;
-
-// Get best colormodel for hardware acceleration
-
-	result = File::get_best_colormodel(asset, device->in_config->driver);
-
-
-// Need to get color model before opening device but don't call this
-// unless you want to open the device either.
-	if(!initialization_complete)
-	{
-		device_colormodel = translate_colormodel(result);
-		this->colormodel = result;
-		v4l_init();
-		initialization_complete = 1;
-	}
-// printf("VDeviceV4L::get_best_colormodel %c%c%c%c\n", 
-// 	((char*)&device_colormodel)[0],
-// 	((char*)&device_colormodel)[1],
-// 	((char*)&device_colormodel)[2],
-// 	((char*)&device_colormodel)[3]);
-	return result;
-}
-
-unsigned long VDeviceV4L::translate_colormodel(int colormodel)
-{
-	unsigned long result = 0;
-	switch(colormodel)
-	{
-		case BC_YUV422:      result = VIDEO_PALETTE_YUV422;      break;
-		case BC_YUV420P:     result = VIDEO_PALETTE_YUV420P;     break;
-		case BC_YUV422P:     result = VIDEO_PALETTE_YUV422P;     break;
-		case BC_YUV411P:     result = VIDEO_PALETTE_YUV411P;     break;
-		case BC_RGB888:      result = VIDEO_PALETTE_RGB24;       break;
-		default: result = VIDEO_PALETTE_RGB24; break;
-	}
-//printf("VDeviceV4L::translate_colormodel %d\n", result);
-	return result;
-}
-
-int VDeviceV4L::set_channel(Channel *channel)
-{
-	return v4l1_set_channel(channel);
-}
-
-int VDeviceV4L::v4l1_set_channel(Channel *channel)
-{
-	struct video_channel channel_struct;
-	struct video_tuner tuner_struct;
-	unsigned long new_freq;
-
-// Mute changed the input to TV
-//	set_mute(1);
-
-//printf("VDeviceV4L::v4l1_set_channel 1 %d\n", channel->input);
-// Read norm/input defaults
-	channel_struct.channel = channel->input;
-	if(ioctl(input_fd, VIDIOCGCHAN, &channel_struct) < 0)
-		perror("VDeviceV4L::v4l1_set_channel VIDIOCGCHAN");
-
-// Set norm/input
-	channel_struct.channel = channel->input;
-	channel_struct.norm = v4l1_get_norm(channel->norm);
-	if(ioctl(input_fd, VIDIOCSCHAN, &channel_struct) < 0)
-		perror("VDeviceV4L::v4l1_set_channel VIDIOCSCHAN");
-
-	if(channel_struct.flags & VIDEO_VC_TUNER)
-	{
-// Read tuner defaults
-		tuner_struct.tuner = channel->input;
-		if(ioctl(input_fd, VIDIOCGTUNER, &tuner_struct) < 0)
-			perror("VDeviceV4L::v4l1_set_channel VIDIOCGTUNER");
-
-// Set tuner
-		tuner_struct.mode = v4l1_get_norm(channel->norm);
-		if(ioctl(input_fd, VIDIOCSTUNER, &tuner_struct) < 0)
-			perror("VDeviceV4L::v4l1_set_channel VIDIOCSTUNER");
-
-		new_freq = chanlists[channel->freqtable].list[channel->entry].freq;
-		new_freq = (int)(new_freq * 0.016);
-		new_freq += channel->fine_tune;
-
-		if(ioctl(input_fd, VIDIOCSFREQ, &new_freq) < 0)
-			perror("VDeviceV4L::v4l1_set_channel VIDIOCSFREQ");
-	}
-//	set_mute(0);
-	return 0;
-}
-
-int VDeviceV4L::v4l1_get_norm(int norm)
-{
-	switch(norm)
-	{
-		case NTSC:         return VIDEO_MODE_NTSC;         break;
-		case PAL:          return VIDEO_MODE_PAL;          break;
-		case SECAM:        return VIDEO_MODE_SECAM;        break;
-	}
-	return 0;
-}
-
-int VDeviceV4L::set_picture(PictureConfig *picture)
-{
-	v4l1_set_picture(picture);
-}
-
-
-int VDeviceV4L::v4l1_set_picture(PictureConfig *picture)
-{
-	int brightness = (int)((float)picture->brightness / 100 * 32767 + 32768);
-	int hue = (int)((float)picture->hue / 100 * 32767 + 32768);
-	int color = (int)((float)picture->color / 100 * 32767 + 32768);
-	int contrast = (int)((float)picture->contrast / 100 * 32767 + 32768);
-	int whiteness = (int)((float)picture->whiteness / 100 * 32767 + 32768);
-
-	if(ioctl(input_fd, VIDIOCGPICT, &picture_params) < 0)
-		perror("VDeviceV4L::v4l1_set_picture VIDIOCGPICT");
-	picture_params.brightness = brightness;
-	picture_params.hue = hue;
-	picture_params.colour = color;
-	picture_params.contrast = contrast;
-	picture_params.whiteness = whiteness;
-// Bogus.  Values are only set in the capture routine.
-	picture_params.depth = 3;
-	picture_params.palette = device_colormodel;
-	if(ioctl(input_fd, VIDIOCSPICT, &picture_params) < 0)
-		perror("VDeviceV4L::v4l1_set_picture VIDIOCSPICT");
-	if(ioctl(input_fd, VIDIOCGPICT, &picture_params) < 0)
-		perror("VDeviceV4L::v4l1_set_picture VIDIOCGPICT");
-	return 0;
-}
-
-
-int VDeviceV4L::capture_frame(int capture_frame_number)
-{
-	struct video_mmap params;
-	params.frame = capture_frame_number;
-	params.width = device->in_config->w;
-	params.height = device->in_config->h;
-// Required to actually set the palette.
-	params.format = device_colormodel;
-// Tells the driver the buffer is available for writing
-	if(ioctl(input_fd, VIDIOCMCAPTURE, &params) < 0)
-		perror("VDeviceV4L::capture_frame VIDIOCMCAPTURE");
-	return 0;
-}
-
-int VDeviceV4L::wait_v4l_frame()
-{
-//printf("VDeviceV4L::wait_v4l_frame 1 %d\n", capture_frame_number);
-	if(ioctl(input_fd, VIDIOCSYNC, &capture_frame_number))
-		perror("VDeviceV4L::wait_v4l_frame VIDIOCSYNC");
-//printf("VDeviceV4L::wait_v4l_frame 2 %d\n", capture_frame_number);
-	return 0;
-}
-
-int VDeviceV4L::read_v4l_frame(VFrame *frame)
-{
-	frame_to_vframe(frame, (unsigned char*)capture_buffer + capture_params.offsets[capture_frame_number]);
-	return 0;
-}
-
-#ifndef MIN
-#define MIN(x, y) ((x) < (y) ? (x) : (y))
-#endif
-
-int VDeviceV4L::frame_to_vframe(VFrame *frame, unsigned char *input)
-{
-	int inwidth, inheight;
-	int width, height;
-
-	inwidth = window_params.width;
-	inheight = window_params.height;
-
-	width = MIN(inwidth, frame->get_w());
-	height = MIN(inheight, frame->get_h());
-//printf("VDeviceV4L::frame_to_vframe %d %d\n", colormodel, frame->get_color_model());
-
-	if(frame->get_color_model() == colormodel)
-	{
-		switch(frame->get_color_model())
-		{
-			case BC_RGB888:
-			{
-				unsigned char *row_in;
-				unsigned char *row_out_start, *row_out_end;
-				int bytes_per_inrow = inwidth * 3;
-				int bytes_per_outrow = frame->get_bytes_per_line();
-				unsigned char **rows_out = frame->get_rows();
-
-				for(int i = 0; i < frame->get_h(); i++)
-				{
-					row_in = input + bytes_per_inrow * i;
-					row_out_start = rows_out[i];
-					row_out_end = row_out_start + 
-						MIN(bytes_per_outrow, bytes_per_inrow);
-
-					while(row_out_start < row_out_end)
-					{
-						*row_out_start++ = row_in[2];
-						*row_out_start++ = row_in[1];
-						*row_out_start++ = row_in[0];
-						row_in += 3;
-					}
-				}
-				break;
-			}
-
-			case BC_YUV420P:
-			case BC_YUV411P:
-				memcpy(frame->get_y(), input, width * height);
-				memcpy(frame->get_u(), input + width * height, width * height / 4);
-				memcpy(frame->get_v(), input + width * height + width * height / 4, width * height / 4);
-				break;
-
-			case BC_YUV422P:
-				memcpy(frame->get_y(), input, width * height);
-				memcpy(frame->get_u(), input + width * height, width * height / 2);
-				memcpy(frame->get_v(), input + width * height + width * height / 2, width * height / 2);
-				break;
-
-			case BC_YUV422:
-				memcpy(frame->get_data(), 
-					input, 
-					VFrame::calculate_data_size(width, 
-						height, 
-						-1, 
-						frame->get_color_model()));
-				break;
-		}
-	}
-	else
-	{
-		VFrame *in_frame = new VFrame(input, 
-			inwidth, 
-			inheight, 
-			colormodel, 
-			-1);
-		cmodel_transfer(frame->get_rows(), 
-			in_frame->get_rows(),
-			frame->get_y(),
-			frame->get_u(),
-			frame->get_v(),
-			in_frame->get_y(),
-			in_frame->get_u(),
-			in_frame->get_v(),
-			0, 
-			0, 
-			inwidth, 
-			inheight,
-			0, 
-			0, 
-			frame->get_w(), 
-			frame->get_h(),
-			colormodel, 
-			frame->get_color_model(),
-			0,
-			inwidth,
-			inheight);
-	}
-	return 0;
-}
-
-
-
-int VDeviceV4L::next_frame(int previous_frame)
-{
-	int result = previous_frame + 1;
-
-	if(result >= MIN(capture_params.frames, device->in_config->capture_length)) result = 0;
-	return result;
-}
-
-int VDeviceV4L::read_buffer(VFrame *frame)
-{
-	int result = 0;
-
-SET_TRACE
-	if(shared_memory)
-	{
-// Read the current frame
-		if(!got_first_frame) v4l1_start_capture();
-		wait_v4l_frame();
-		read_v4l_frame(frame);
-// Free this frame up for capturing
-		capture_frame(capture_frame_number);
-// Advance the frame to capture.
-		capture_frame_number = next_frame(capture_frame_number);
-	}
-	else
-	{
-		read(input_fd, capture_buffer, capture_params.size);
-	}
-	got_first_frame = 1;
-SET_TRACE
-
-	return 0;
-}
-
-
-
-
-
-
-
-
-
-
-
diff -Nru cinelerra.orig//cinelerra/vdevicev4l.h cinelerra/cinelerra/vdevicev4l.h
--- cinelerra.orig//cinelerra/vdevicev4l.h	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/vdevicev4l.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,83 +0,0 @@
-
-/*
- * CINELERRA
- * Copyright (C) 2008 Adam Williams <broadcast at earthling dot net>
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- * 
- */
-
-#ifndef VDEVICEV4L_H
-#define VDEVICEV4L_H
-
-#include "vdevicebase.h"
-#include <linux/videodev.h>
-#include "videodevice.inc"
-
-class VDeviceV4L : public VDeviceBase
-{
-public:
-	VDeviceV4L(VideoDevice *device);
-	~VDeviceV4L();
-
-	int initialize();
-	int open_input();
-	int close_all();
-	int read_buffer(VFrame *frame);
-	int get_best_colormodel(Asset *asset);
-	int set_channel(Channel *channel);
-	int set_picture(PictureConfig *picture);
-
-private:
-	int set_cloexec_flag(int desc, int value);
-	int set_mute(int muted);
-	int v4l1_get_inputs();
-	int v4l1_set_mute(int muted);
-	unsigned long translate_colormodel(int colormodel);
-	int v4l1_set_channel(Channel *channel);
-	int v4l1_get_norm(int norm);
-	int v4l1_set_picture(PictureConfig *picture);
-	void v4l1_start_capture();
-	int capture_frame(int capture_frame_number);
-	int wait_v4l_frame();
-	int read_v4l_frame(VFrame *frame);
-	int frame_to_vframe(VFrame *frame, unsigned char *input);
-	int next_frame(int previous_frame);
-	int close_v4l();
-	int unmap_v4l_shmem();
-	int v4l_init();
-
-	int input_fd, output_fd;
-// FourCC Colormodel for device
-	unsigned long device_colormodel;
-// BC colormodel for device
-	int colormodel;
-
-// Video4Linux
-	struct video_capability cap1;
-	struct video_window window_params;
-	struct video_picture picture_params;
-	struct video_mbuf capture_params;  // Capture for Video4Linux
-
-// Common
-	char *capture_buffer;      // sequentual capture buffers for v4l1 or read buffer for v4l2
-	int capture_frame_number;    // number of frame to capture into
-	int read_frame_number;       // number of the captured frame to read
-	int shared_memory;   // Capturing directly to memory
-	int initialization_complete;
-	int got_first_frame;
-};
-
-#endif
diff -Nru cinelerra.orig//cinelerra/vdevicev4l.inc cinelerra/cinelerra/vdevicev4l.inc
--- cinelerra.orig//cinelerra/vdevicev4l.inc	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/vdevicev4l.inc	1969-12-31 19:00:00.000000000 -0500
@@ -1,27 +0,0 @@
-
-/*
- * CINELERRA
- * Copyright (C) 2008 Adam Williams <broadcast at earthling dot net>
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- * 
- */
-
-#ifndef VDEVICEV4L_INC
-#define VDEVICEV4L_INC
-
-class VDeviceV4L;
-
-#endif
diff -Nru cinelerra.orig//cinelerra/videodevice.C cinelerra/cinelerra/videodevice.C
--- cinelerra.orig//cinelerra/videodevice.C	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/videodevice.C	2011-02-17 13:41:53.239880001 -0500
@@ -39,9 +39,9 @@
 #ifdef HAVE_FIREWIRE
 #include "vdevice1394.h"
 #endif
-#include "vdevicebuz.h"
+//#include "vdevicebuz.h"
 #include "vdevicedvb.h"
-#include "vdevicev4l.h"
+//#include "vdevicev4l.h"
 #include "vdevicev4l2.h"
 #include "vdevicev4l2jpeg.h"
 #include "vdevicex11.h"
@@ -203,7 +203,6 @@
 			result = input_base->open_input();
 			break;
 
-
 #ifdef HAVE_VIDEO4LINUX2
 		case VIDEO4LINUX2:
 			new_device_base();
@@ -250,8 +249,8 @@
 {
 	switch(in_config->driver)
 	{
-		case VIDEO4LINUX:
-			return input_base = new VDeviceV4L(this);
+		//case VIDEO4LINUX:
+		//	return input_base = new VDeviceV4L(this);
 
 #ifdef HAVE_VIDEO4LINUX2
 		case VIDEO4LINUX2:
@@ -264,8 +263,8 @@
 		case SCREENCAPTURE:
 			return input_base = new VDeviceX11(this, 0);
 
-		case CAPTURE_BUZ:
-			return input_base = new VDeviceBUZ(this);
+		//case CAPTURE_BUZ:
+		//	return input_base = new VDeviceBUZ(this);
 
 #ifdef HAVE_FIREWIRE
 		case CAPTURE_FIREWIRE:
@@ -662,9 +661,9 @@
 //printf("VideoDevice::open_output 1 %d\n", out_config->driver);
 	switch(out_config->driver)
 	{
-		case PLAYBACK_BUZ:
-			output_base = new VDeviceBUZ(this);
-			break;
+		//case PLAYBACK_BUZ:
+		//	output_base = new VDeviceBUZ(this);
+		//	break;
 		case PLAYBACK_X11:
 		case PLAYBACK_X11_XV:
 		case PLAYBACK_X11_GL:
diff -Nru cinelerra.orig//cinelerra/videodevice.h cinelerra/cinelerra/videodevice.h
--- cinelerra.orig//cinelerra/videodevice.h	2010-11-24 18:18:03.000000000 -0500
+++ cinelerra/cinelerra/videodevice.h	2011-02-17 13:31:30.167880002 -0500
@@ -40,9 +40,9 @@
 #include "thread.h"
 #include "picture.inc"
 #include "vdevicebase.inc"
-#include "vdevicebuz.inc"
+//#include "vdevicebuz.inc"
 #include "vdevicelml.inc"
-#include "vdevicev4l.inc"
+//#include "vdevicev4l.inc"
 #include "vdevicex11.inc"
 #include "videoconfig.inc"
 #include "videowindow.inc"
--- cinelerra-cv/cinelerra/Makefile.am~	2011-04-06 20:33:34.474397085 +0200
+++ cinelerra-cv/cinelerra/Makefile.am	2011-04-06 20:36:44.323074826 +0200
@@ -628,7 +628,6 @@
 		 vautomation.h \
 		 vdevice1394.h \
 		 vdevicebase.h \
-		 vdevicebuz.h \
 		 vdevicedvb.h \
 		 vdevicelml.h \
 		 vdeviceprefs.h \
--- cinelerra-cv/cinelerra/Makefile.am~	2011-04-06 20:37:25.104939175 +0200
+++ cinelerra-cv/cinelerra/Makefile.am	2011-04-06 20:40:03.768860034 +0200
@@ -631,7 +631,6 @@
 		 vdevicedvb.h \
 		 vdevicelml.h \
 		 vdeviceprefs.h \
-		 vdevicev4l.h \
 		 vdevicev4l2.h \
 		 vdevicev4l2jpeg.h \
 		 vdevicex11.h \
